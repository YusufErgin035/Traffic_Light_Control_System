package com.example.trafficlightcontrolsystem;

import javafx.animation.PathTransition;
import javafx.animation.Timeline;
import javafx.animation.KeyFrame;
import javafx.scene.layout.AnchorPane;
import javafx.scene.paint.Color;
import javafx.scene.shape.Line;
import javafx.util.Duration;

import java.util.ArrayList;
import java.util.List;
import java.util.Random;

public class DestinationMaker {
    private graph g;
    private int start;
    private int end;
    private Car car;
    private AnchorPane pane;
    private List<Integer> fullPath;
    private TrafficLightSystem trafficSystem;
    private int currentEdgeIndex = 0;
    private List<Timeline> activeTimelines = new ArrayList<>();
    private List<PathTransition> activeTransitions = new ArrayList<>();

    public DestinationMaker(graph g, AnchorPane pane, TrafficLightSystem trafficSystem) {
        Random rand = new Random();
        this.pane = pane;
        this.g = g;
        this.trafficSystem = trafficSystem;
        this.start = rand.nextInt(0,7);
        do{
            this.end = rand.nextInt(0,7);
        }while(this.end == this.start);

        this.fullPath = g.dijkstra(this.start,this.end);

        // ƒ∞lk edge'in vehicle count'ƒ±nƒ± artƒ±r (ara√ß yola √ßƒ±kƒ±yor)
        if (this.fullPath.size() > 1) {
            System.out.println("YENƒ∞ ARA√á: " + this.fullPath.get(0) + "->" + this.fullPath.get(1));
            g.incrementVehicle(this.fullPath.get(0), this.fullPath.get(1));
        }

        double red = rand.nextDouble();
        double green = rand.nextDouble();
        double blue = rand.nextDouble();
        Edge edge = g.getEdge(fullPath.get(0),fullPath.get(1));
        this.car = new Car(0, 0, Color.color(red,green,blue), edge.calcLine());
        this.pane.getChildren().add(car.getShape());
        moveCarAlongPath(0);
    }

    private void moveCarAlongPath(int index) {
        if (index >= fullPath.size() - 1) {
            //  Son durumda t√ºm ara√ß bilgilerini temizle
            if (index > 0) {
                System.out.println("SON ARA√á √áIKIYOR: " + fullPath.get(index-1) + "->" + fullPath.get(index));
                g.decrementVehicle(fullPath.get(index-1), fullPath.get(index));
            }
            cleanup();
            this.pane.getChildren().remove(car.getShape());
            System.out.println("Ara√ß tamamen temizlendi");
            return;
        }

        int from = this.fullPath.get(index);
        int to = this.fullPath.get(index + 1);
        Edge edge = g.getEdge(from, to);
        if (edge == null) {
            System.out.println("Kenar bulunamadƒ±: " + from + " -> " + to);
            return;
        }
        moveCarAlongEdge(edge, index);
    }
    private void checkTrafficLightAndMove(List<Integer> path, int index, Edge edge) {
        System.out.println("DEBUG: checkTrafficLightAndMove √ßaƒüƒ±rƒ±ldƒ± - index: " + index + ", path size: " + path.size());
        // Hangi kav≈üak ve hangi y√∂n olduƒüunu bul
        int from = this.fullPath.get(index);
        int to = this.fullPath.get(index + 1);
        String intersection = getIntersectionName(to);
        int direction = getDirectionIndex(from,to);

        System.out.println("Ara√ß " + from + "->" + to + " yolunda, kav≈üak: " + intersection + ", y√∂n: " + direction);

        if (intersection != null && direction != -1) {
            // I≈üƒ±k kontrol√º yap
            if (isLightGreen(intersection, direction)) {
                System.out.println("Ye≈üil ƒ±≈üƒ±k - ara√ß ge√ßiyor");
                // Ye≈üil ƒ±≈üƒ±k - ge√ß
                if (index > 0) {
                    this.g.decrementVehicle(path.get(index - 1), path.get(index));
                }
                // Sonraki edge'e gir (eƒüer varsa)
                if (index + 2 < path.size()) {
                    this.g.incrementVehicle(path.get(index + 1), path.get(index + 2));
                }
                if (index <path.size()-1) {
                    Edge nextEdge = this.g.getEdge(path.get(index+1), path.get(index+2));
                    if (needsTurn(edge, nextEdge)) {
                        boolean clockwise = shouldTurnClockwise(edge, nextEdge);
                        this.car.arcTurn(clockwise);
                    }
                }
                moveCarAlongPath(index+1);
            } else {
                System.out.println("Kƒ±rmƒ±zƒ± ƒ±≈üƒ±k - ara√ß bekliyor");
                // Kƒ±rmƒ±zƒ± ƒ±≈üƒ±k - bekle ve tekrar kontrol et
                if (this.car.isWaiting()) {
                    // Ara√ß zaten bekliyorsa yeni bir Timeline ba≈ülatma
                    return;
                }

                this.car.setWaiting(true); // Ara√ß bekleme durumuna ge√ßiyor

                Timeline waitTimeline = new Timeline(
                        new KeyFrame(Duration.millis(500), e -> {
                            this.car.setWaiting(false);
                            checkTrafficLightAndMove(path,index,edge);
                        })
                );
                activeTimelines.add(waitTimeline);
                waitTimeline.setCycleCount(1);
                waitTimeline.play();
            }
        } else {
            System.out.println("Intersection bulunamadƒ± - normal hareket");
            // Intersection bulunamadƒ±, normal hareket et
            moveCarAlongEdge(edge,index+1);
        }
    }

    private void moveCarAlongEdge(Edge edge,int index) {
        Line line = new Line(edge.fromX, edge.fromY, edge.toX, edge.toY);
        PathTransition transition = new PathTransition();
        transition.setDuration(Duration.seconds(edge.roadTime));
        transition.setPath(line);
        transition.setNode(this.car.getShape());
        transition.setCycleCount(1);
        transition.setAutoReverse(false);

        activeTransitions.add(transition);

        if(index == fullPath.size()-2) {
            //  SON ARA√á DURUMU - Sadece g√∂rsel sil, graph temizliƒüi cleanup()'ta
            transition.setOnFinished(event -> {
                // G√∂rsel elementi sil
                this.pane.getChildren().remove(car.getShape());

                // Graph temizliƒüi
                cleanup();

                System.out.println("Son ara√ß tamamen temizlendi");
            });
        }
        else{
            transition.setOnFinished(event -> checkTrafficLightAndMove(fullPath,index,edge));
        }
        transition.play();
    }

    private void performMovement(List<Integer> path, int index, Edge edge) {
        // D√∂n√º≈ü kontrol√º
        if (index > 0 && index <path.size()-1) {
            Edge previousEdge = g.getEdge(path.get(index - 1), path.get(index));
            if (previousEdge != null && needsTurn(previousEdge, edge)) {
                boolean clockwise = shouldTurnClockwise(previousEdge, edge);
                car.arcTurn(clockwise);
            }
        }

        // Hareket animasyonu
        Line line = new Line(edge.fromX, edge.fromY, edge.toX, edge.toY);
        PathTransition transition = new PathTransition();
        transition.setDuration(Duration.seconds(edge.roadTime));
        transition.setPath(line);
        transition.setNode(car.getShape());
        transition.setCycleCount(1);
        transition.setAutoReverse(false);

        activeTransitions.add(transition); //  Sadece bu satƒ±rƒ± ekle

        transition.setOnFinished(event -> {
            syncGraphWithAnimation();
            if (currentEdgeIndex >= fullPath.size() - 1) {
                cleanup(); //  Bu satƒ±rƒ± ekle
                this.pane.getChildren().remove(car.getShape());
                return;
            }
            moveCarAlongPath(currentEdgeIndex + 1);
        });
        transition.play();
    }

    private void cleanup() {
        // √ñNCE graph'taki t√ºm bu ara√ß i√ßin aktif edge'leri temizle
        for (int i = 0; i < fullPath.size() - 1; i++) {
            int from = fullPath.get(i);
            int to = fullPath.get(i + 1);
            Edge edge = g.getEdge(from, to);
            if (edge != null && edge.vehicleCount > 0) {
                System.out.println("üßπ CLEANUP: Edge " + from + "->" + to + " temizleniyor (" + edge.vehicleCount + " -> " + (edge.vehicleCount - 1) + ")");
                edge.vehicleCount--;
            }
        }

        // Sonra animasyonlarƒ± temizle
        car.cleanup();

        for(PathTransition pt : activeTransitions) {
            pt.stop();
        }
        for(Timeline tl : activeTimelines) {
            tl.stop();
        }
        activeTransitions.clear();
        activeTimelines.clear();
    }

    private String getIntersectionName(int nodeId) {
        switch (nodeId) {
            case 8: return "lu";  // Sol √ºst
            case 9: return "ru";  // Saƒü √ºst
            case 10: return "ld"; // Sol alt
            case 11: return "rd"; // Saƒü alt
            default: return null;
        }
    }

    private int getDirectionIndex(int from, int to) {
        // Her kav≈üak i√ßin gelen y√∂nlerin indeksini d√∂nd√ºr
        switch (to) {
            case 8: // Sol √ºst kav≈üak
                if (from == 7) return 0;  // Soldan
                if (from == 0) return 1;  // √ústten
                if (from == 10) return 2; // Alttan
                if (from == 9) return 3;  // Saƒüdan
                break;
            case 9: // Saƒü √ºst kav≈üak
                if (from == 8) return 0;  // Soldan
                if (from == 1) return 1;  // √ústten
                if (from == 11) return 2; // Alttan
                if (from == 2) return 3;  // Saƒüdan
                break;
            case 10: // Sol alt kav≈üak
                if (from == 6) return 0;  // Soldan
                if (from == 8) return 1;  // √ústten
                if (from == 5) return 2;  // Alttan
                if (from == 11) return 3; // Saƒüdan
                break;
            case 11: // Saƒü alt kav≈üak
                if (from == 10) return 0; // Soldan
                if (from == 9) return 1;  // √ústten
                if (from == 4) return 2;  // Alttan
                if (from == 3) return 3;  // Saƒüdan
                break;
        }
        return -1;
    }

    private boolean isLightGreen(String intersection, int direction) {
        // TrafficLightSystem'den ƒ±≈üƒ±k durumunu kontrol et
        // Bu metod i√ßin TrafficLightSystem'e eri≈üim gerekiyor
        return trafficSystem.isLightGreen(intersection, direction);
    }

    private boolean needsTurn(Edge previousEdge, Edge currentEdge) {
        double prevAngle = Math.toDegrees(Math.atan2(
                previousEdge.toY - previousEdge.fromY,
                previousEdge.toX - previousEdge.fromX
        ));

        double currAngle = Math.toDegrees(Math.atan2(
                currentEdge.toY - currentEdge.fromY,
                currentEdge.toX - currentEdge.fromX
        ));

        double diff = Math.abs(currAngle - prevAngle);
        while (diff > 180) diff -= 360;
        diff = Math.abs(diff);

        return diff > 10;
    }

    private boolean shouldTurnClockwise(Edge previousEdge, Edge currentEdge) {
        double prevAngle = Math.toDegrees(Math.atan2(
                previousEdge.toY - previousEdge.fromY,
                previousEdge.toX - previousEdge.fromX
        ));

        double currAngle = Math.toDegrees(Math.atan2(
                currentEdge.toY - currentEdge.fromY,
                currentEdge.toX - currentEdge.fromX
        ));

        double diff = currAngle - prevAngle;
        while (diff > 180) diff -= 360;
        while (diff < -180) diff += 360;

        return diff > 0;
    }

    private void syncGraphWithAnimation() {
        // Mevcut konumu graph'tan temizle
        if (currentEdgeIndex > 0 && currentEdgeIndex < fullPath.size()) {
            System.out.println("Ara√ß √ßƒ±kƒ±yor: " + fullPath.get(currentEdgeIndex - 1) + "->" + fullPath.get(currentEdgeIndex));
            g.decrementVehicle(fullPath.get(currentEdgeIndex - 1), fullPath.get(currentEdgeIndex));
        }

        // Yeni konuma kaydet
        if (currentEdgeIndex + 1 < fullPath.size()) {
            System.out.println("Ara√ß giriyor: " + fullPath.get(currentEdgeIndex) + "->" + fullPath.get(currentEdgeIndex + 1));
            g.incrementVehicle(fullPath.get(currentEdgeIndex), fullPath.get(currentEdgeIndex + 1));
        }

        currentEdgeIndex++;
    }
}